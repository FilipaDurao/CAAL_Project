<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CAALProject: Graph&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CAALProject
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classGraph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Graph&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8c626ac04708ae490bba05e1e713cda2"><td class="memItemLeft" align="right" valign="top"><a id="a8c626ac04708ae490bba05e1e713cda2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a8c626ac04708ae490bba05e1e713cda2">Graph</a> ()</td></tr>
<tr class="memdesc:a8c626ac04708ae490bba05e1e713cda2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classGraph.html">Graph</a>. <br /></td></tr>
<tr class="separator:a8c626ac04708ae490bba05e1e713cda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43eab1460b5c8ceaa526b40e56a0fb0c"><td class="memItemLeft" align="right" valign="top"><a id="a43eab1460b5c8ceaa526b40e56a0fb0c"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a43eab1460b5c8ceaa526b40e56a0fb0c">~Graph</a> ()</td></tr>
<tr class="memdesc:a43eab1460b5c8ceaa526b40e56a0fb0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a <a class="el" href="classGraph.html">Graph</a>. <br /></td></tr>
<tr class="separator:a43eab1460b5c8ceaa526b40e56a0fb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea21fd30bc10f1a9ee6ff88b69fff512"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#aea21fd30bc10f1a9ee6ff88b69fff512">addNode</a> (T nodeData, int x, int y)</td></tr>
<tr class="memdesc:aea21fd30bc10f1a9ee6ff88b69fff512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classNode.html">Node</a> and adds it to the <a class="el" href="classGraph.html">Graph</a>.  <a href="#aea21fd30bc10f1a9ee6ff88b69fff512">More...</a><br /></td></tr>
<tr class="separator:aea21fd30bc10f1a9ee6ff88b69fff512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb367245cc8f3720b02cbd6655f138c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#aefb367245cc8f3720b02cbd6655f138c">getNumNodes</a> () const</td></tr>
<tr class="memdesc:aefb367245cc8f3720b02cbd6655f138c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of Nodes in the <a class="el" href="classGraph.html">Graph</a>.  <a href="#aefb367245cc8f3720b02cbd6655f138c">More...</a><br /></td></tr>
<tr class="separator:aefb367245cc8f3720b02cbd6655f138c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5655f220455405e30b7fb572f030e3f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNode.html">Node</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a5655f220455405e30b7fb572f030e3f6">getNodeByID</a> (unsigned int ID) const</td></tr>
<tr class="memdesc:a5655f220455405e30b7fb572f030e3f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a node by its ID.  <a href="#a5655f220455405e30b7fb572f030e3f6">More...</a><br /></td></tr>
<tr class="separator:a5655f220455405e30b7fb572f030e3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2e0a5846210fd7ce91656e1eddc84d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a9c2e0a5846210fd7ce91656e1eddc84d">getNumEdges</a> () const</td></tr>
<tr class="memdesc:a9c2e0a5846210fd7ce91656e1eddc84d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of Edges in the <a class="el" href="classGraph.html">Graph</a>.  <a href="#a9c2e0a5846210fd7ce91656e1eddc84d">More...</a><br /></td></tr>
<tr class="separator:a9c2e0a5846210fd7ce91656e1eddc84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7901286a40035bfc40410c639238bc7"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classNode.html">Node</a>&lt; T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ab7901286a40035bfc40410c639238bc7">getNodes</a> () const</td></tr>
<tr class="memdesc:ab7901286a40035bfc40410c639238bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all the Nodes in the <a class="el" href="classGraph.html">Graph</a>.  <a href="#ab7901286a40035bfc40410c639238bc7">More...</a><br /></td></tr>
<tr class="separator:ab7901286a40035bfc40410c639238bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100f3444fb02165e585da855d4746c63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a100f3444fb02165e585da855d4746c63">findInterfaces</a> ()</td></tr>
<tr class="memdesc:a100f3444fb02165e585da855d4746c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks which nodes of the graph are an interface for the different types of transports.  <a href="#a100f3444fb02165e585da855d4746c63">More...</a><br /></td></tr>
<tr class="separator:a100f3444fb02165e585da855d4746c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6bc64165c9bdd422804cd9c6e9bb33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a5b6bc64165c9bdd422804cd9c6e9bb33">addBusEdge</a> (unsigned int sourceNodeID, unsigned int destinyNodeID, double weight, string lineID)</td></tr>
<tr class="memdesc:a5b6bc64165c9bdd422804cd9c6e9bb33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an BusEdge and adds it to a certain existing <a class="el" href="classNode.html">Node</a>.  <a href="#a5b6bc64165c9bdd422804cd9c6e9bb33">More...</a><br /></td></tr>
<tr class="separator:a5b6bc64165c9bdd422804cd9c6e9bb33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0757cca6c1f67a44136441ec5f706311"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a0757cca6c1f67a44136441ec5f706311">addSubwayEdge</a> (unsigned int sourceNodeID, unsigned int destinyNodeID, double weight, string lineID)</td></tr>
<tr class="memdesc:a0757cca6c1f67a44136441ec5f706311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an SubwayEdge and adds it to a certain existing <a class="el" href="classNode.html">Node</a>.  <a href="#a0757cca6c1f67a44136441ec5f706311">More...</a><br /></td></tr>
<tr class="separator:a0757cca6c1f67a44136441ec5f706311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee0b6743558ef8c3636e720fcf8a72a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#aeee0b6743558ef8c3636e720fcf8a72a">addWalkEdge</a> (unsigned int sourceNodeID, unsigned int destinyNodeID, double weight, string lineID)</td></tr>
<tr class="memdesc:aeee0b6743558ef8c3636e720fcf8a72a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an WalkEdge and adds it to a certain existing <a class="el" href="classNode.html">Node</a>.  <a href="#aeee0b6743558ef8c3636e720fcf8a72a">More...</a><br /></td></tr>
<tr class="separator:aeee0b6743558ef8c3636e720fcf8a72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c543627f13b31885115f25743cc8f85"><td class="memItemLeft" align="right" valign="top">vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a5c543627f13b31885115f25743cc8f85">getPath</a> (<a class="el" href="classNode.html">Node</a>&lt; T &gt; *dest) const</td></tr>
<tr class="memdesc:a5c543627f13b31885115f25743cc8f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the path to a certain <a class="el" href="classNode.html">Node</a>  <a href="#a5c543627f13b31885115f25743cc8f85">More...</a><br /></td></tr>
<tr class="separator:a5c543627f13b31885115f25743cc8f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0ad35640cc7e44ebf1b85c2eb077d8"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classNode.html">Node</a>&lt; T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#acf0ad35640cc7e44ebf1b85c2eb077d8">getDetailedPath</a> (<a class="el" href="classNode.html">Node</a>&lt; T &gt; *dest) const</td></tr>
<tr class="memdesc:acf0ad35640cc7e44ebf1b85c2eb077d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives detailed Information about the path to take.  <a href="#acf0ad35640cc7e44ebf1b85c2eb077d8">More...</a><br /></td></tr>
<tr class="separator:acf0ad35640cc7e44ebf1b85c2eb077d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f12b75eac2d9671153262dcc8aeef8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNode.html">Node</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ac0f12b75eac2d9671153262dcc8aeef8">dijkstra_heap</a> (<a class="el" href="classNode.html">Node</a>&lt; T &gt; *startNode, <a class="el" href="classNode.html">Node</a>&lt; T &gt; *endNode)</td></tr>
<tr class="memdesc:ac0f12b75eac2d9671153262dcc8aeef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with the path with the "smallest" distance from the startNode to the endNode, implementing Dijkstra, using a heap.  <a href="#ac0f12b75eac2d9671153262dcc8aeef8">More...</a><br /></td></tr>
<tr class="separator:ac0f12b75eac2d9671153262dcc8aeef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3472c37dbb3f2a2f71b8d24e8560b454"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNode.html">Node</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a3472c37dbb3f2a2f71b8d24e8560b454">dijkstra_queue</a> (<a class="el" href="classNode.html">Node</a>&lt; T &gt; *startNode, <a class="el" href="classNode.html">Node</a>&lt; T &gt; *endNode)</td></tr>
<tr class="memdesc:a3472c37dbb3f2a2f71b8d24e8560b454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the path with the "smallest" distance from the startNode to the endNode, implementing Dijkstra, using a mutable priority queue.  <a href="#a3472c37dbb3f2a2f71b8d24e8560b454">More...</a><br /></td></tr>
<tr class="separator:a3472c37dbb3f2a2f71b8d24e8560b454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3facfe634afadb6f4eb1775b53a02f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNode.html">Node</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ae3facfe634afadb6f4eb1775b53a02f1">dijkstra_queue_NO_WALK</a> (<a class="el" href="classNode.html">Node</a>&lt; T &gt; *startNode, <a class="el" href="classNode.html">Node</a>&lt; T &gt; *endNode)</td></tr>
<tr class="memdesc:ae3facfe634afadb6f4eb1775b53a02f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the path with the "smallest" distance from the startNode to the endNode, without walking, implementing Dijkstra, using a mutable priority queue.  <a href="#ae3facfe634afadb6f4eb1775b53a02f1">More...</a><br /></td></tr>
<tr class="separator:ae3facfe634afadb6f4eb1775b53a02f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a9d017001470ed3462888308cd8222"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNode.html">Node</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a52a9d017001470ed3462888308cd8222">dijkstra_queue_TRANSBORDS</a> (<a class="el" href="classNode.html">Node</a>&lt; T &gt; *startNode, <a class="el" href="classNode.html">Node</a>&lt; T &gt; *endNode, int maxNum)</td></tr>
<tr class="memdesc:a52a9d017001470ed3462888308cd8222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the path with the "smallest" distance from the startNode to the endNode, implementing Dijkstra, using a mutable priority queue, and allowing only some exchanges between transports.  <a href="#a52a9d017001470ed3462888308cd8222">More...</a><br /></td></tr>
<tr class="separator:a52a9d017001470ed3462888308cd8222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6edcfc193c47e8b55bbc537901e4f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNode.html">Node</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#abb6edcfc193c47e8b55bbc537901e4f1">dijkstra_queue_PRICE</a> (<a class="el" href="classNode.html">Node</a>&lt; T &gt; *startNode, <a class="el" href="classNode.html">Node</a>&lt; T &gt; *endNode, double walk_distance)</td></tr>
<tr class="memdesc:abb6edcfc193c47e8b55bbc537901e4f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the cheapest path the startNode to the endNode, implementing Dijkstra, using a mutable priority queue.  <a href="#abb6edcfc193c47e8b55bbc537901e4f1">More...</a><br /></td></tr>
<tr class="separator:abb6edcfc193c47e8b55bbc537901e4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f3e5a786d2f4be17dd94c4626add79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ae1f3e5a786d2f4be17dd94c4626add79">presentPath</a> (vector&lt; <a class="el" href="classNode.html">Node</a>&lt; T &gt; *&gt; invertedPath)</td></tr>
<tr class="memdesc:ae1f3e5a786d2f4be17dd94c4626add79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Presents on the screen the detailed information about the path.  <a href="#ae1f3e5a786d2f4be17dd94c4626add79">More...</a><br /></td></tr>
<tr class="separator:ae1f3e5a786d2f4be17dd94c4626add79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a119f7643728f43f6d882504925c06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classNode.html">Node</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ad1a119f7643728f43f6d882504925c06">A_Star</a> (<a class="el" href="classNode.html">Node</a>&lt; T &gt; *startNode, <a class="el" href="classNode.html">Node</a>&lt; T &gt; *endNode)</td></tr>
<tr class="memdesc:ad1a119f7643728f43f6d882504925c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the path with the "smallest" distance from the startNode to the endNode, using a mutable priority queue and the A Star algorithm.  <a href="#ad1a119f7643728f43f6d882504925c06">More...</a><br /></td></tr>
<tr class="separator:ad1a119f7643728f43f6d882504925c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5ac486160524b62aa4df368cbcf627"><td class="memItemLeft" align="right" valign="top"><a id="aef5ac486160524b62aa4df368cbcf627"></a>
<a class="el" href="classNode.html">Node</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>findNode</b> (const T &amp;in) const</td></tr>
<tr class="separator:aef5ac486160524b62aa4df368cbcf627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6308ddb9d2e3f91e84e861f1023836b6"><td class="memItemLeft" align="right" valign="top"><a id="a6308ddb9d2e3f91e84e861f1023836b6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>addNode</b> (const T &amp;in)</td></tr>
<tr class="separator:a6308ddb9d2e3f91e84e861f1023836b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec1d2579bbdfdaa61b0e468a1809368"><td class="memItemLeft" align="right" valign="top"><a id="a8ec1d2579bbdfdaa61b0e468a1809368"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>addNode</b> (const T &amp;in, int x, int y)</td></tr>
<tr class="separator:a8ec1d2579bbdfdaa61b0e468a1809368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61af3aafe6277215f5a3b3cc7d58ce2"><td class="memItemLeft" align="right" valign="top"><a id="ac61af3aafe6277215f5a3b3cc7d58ce2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>addEdge</b> (const T &amp;sourc, const T &amp;dest, double w)</td></tr>
<tr class="separator:ac61af3aafe6277215f5a3b3cc7d58ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d0961bb1d10014a24fee69fa6e3018"><td class="memItemLeft" align="right" valign="top"><a id="a27d0961bb1d10014a24fee69fa6e3018"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>addEdge</b> (const T &amp;sourc, const T &amp;dest)</td></tr>
<tr class="separator:a27d0961bb1d10014a24fee69fa6e3018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb367245cc8f3720b02cbd6655f138c"><td class="memItemLeft" align="right" valign="top"><a id="aefb367245cc8f3720b02cbd6655f138c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumNodes</b> () const</td></tr>
<tr class="separator:aefb367245cc8f3720b02cbd6655f138c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf0aca65fa2a27c65f9dbc260114438"><td class="memItemLeft" align="right" valign="top"><a id="abbf0aca65fa2a27c65f9dbc260114438"></a>
vector&lt; <a class="el" href="classNode.html">Node</a>&lt; T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getNodes</b> () const</td></tr>
<tr class="separator:abbf0aca65fa2a27c65f9dbc260114438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656e95dbd1cf16d4358c0011445b7c26"><td class="memItemLeft" align="right" valign="top"><a id="a656e95dbd1cf16d4358c0011445b7c26"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumEdges</b> ()</td></tr>
<tr class="separator:a656e95dbd1cf16d4358c0011445b7c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b897dce2b7fe85e8d9d0cf1b306828"><td class="memItemLeft" align="right" valign="top"><a id="a98b897dce2b7fe85e8d9d0cf1b306828"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>listNodes</b> ()</td></tr>
<tr class="separator:a98b897dce2b7fe85e8d9d0cf1b306828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4985f4cb3edc5d5e092dfd63cc552b5c"><td class="memItemLeft" align="right" valign="top"><a id="a4985f4cb3edc5d5e092dfd63cc552b5c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dijkstra_queue</b> (const T &amp;s)</td></tr>
<tr class="separator:a4985f4cb3edc5d5e092dfd63cc552b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbfd0e0f376745c64cc6aef4575868e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a0bbfd0e0f376745c64cc6aef4575868e">dijkstra_heap</a> (const T &amp;s)</td></tr>
<tr class="memdesc:a0bbfd0e0f376745c64cc6aef4575868e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with the path with the "smallest" distance from the startNode to the endNode, using a heap.  <a href="#a0bbfd0e0f376745c64cc6aef4575868e">More...</a><br /></td></tr>
<tr class="separator:a0bbfd0e0f376745c64cc6aef4575868e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1bb2bad653dcfee34f0083f58d0e374"><td class="memItemLeft" align="right" valign="top"><a id="ae1bb2bad653dcfee34f0083f58d0e374"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>A_Star</b> (const T &amp;s, const T &amp;endNode)</td></tr>
<tr class="separator:ae1bb2bad653dcfee34f0083f58d0e374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4ce8ece40bfb876f2e2ac3c30e3bfa"><td class="memItemLeft" align="right" valign="top"><a id="a4f4ce8ece40bfb876f2e2ac3c30e3bfa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dijkstra_queue_end</b> (const T &amp;s, const T &amp;endNode)</td></tr>
<tr class="separator:a4f4ce8ece40bfb876f2e2ac3c30e3bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01256e73f6bacd17af49a15f457009f3"><td class="memItemLeft" align="right" valign="top"><a id="a01256e73f6bacd17af49a15f457009f3"></a>
vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getPath</b> (const T &amp;origin, const T &amp;dest) const</td></tr>
<tr class="separator:a01256e73f6bacd17af49a15f457009f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad1a119f7643728f43f6d882504925c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a119f7643728f43f6d882504925c06">&#9670;&nbsp;</a></span>A_Star()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNode.html">Node</a>&lt; T &gt; * <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::A_Star </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>startNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>endNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the path with the "smallest" distance from the startNode to the endNode, using a mutable priority queue and the A Star algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startNode</td><td>- the beginning <a class="el" href="classNode.html">Node</a> of the path </td></tr>
    <tr><td class="paramname">endNode</td><td>- the end <a class="el" href="classNode.html">Node</a> of the path</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classNode.html">Node</a> * - the final <a class="el" href="classNode.html">Node</a> of the path, so we can walk it back to get the best path </dd></dl>

</div>
</div>
<a id="a5b6bc64165c9bdd422804cd9c6e9bb33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6bc64165c9bdd422804cd9c6e9bb33">&#9670;&nbsp;</a></span>addBusEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::addBusEdge </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sourceNodeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>destinyNodeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>lineID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an BusEdge and adds it to a certain existing <a class="el" href="classNode.html">Node</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceNodeID</td><td>- the ID of the source <a class="el" href="classNode.html">Node</a> of the <a class="el" href="classEdge.html">Edge</a> </td></tr>
    <tr><td class="paramname">destinyNodeID</td><td>- the ID of the destiny <a class="el" href="classNode.html">Node</a> of the <a class="el" href="classEdge.html">Edge</a> </td></tr>
    <tr><td class="paramname">weight</td><td>- the weight of the <a class="el" href="classEdge.html">Edge</a> </td></tr>
    <tr><td class="paramname">lineID</td><td>- the ID of the bus line </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea21fd30bc10f1a9ee6ff88b69fff512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea21fd30bc10f1a9ee6ff88b69fff512">&#9670;&nbsp;</a></span>addNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::addNode </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>nodeData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classNode.html">Node</a> and adds it to the <a class="el" href="classGraph.html">Graph</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeData</td><td>- the data with which we create a <a class="el" href="classNode.html">Node</a> </td></tr>
    <tr><td class="paramname">x</td><td>- the x position of the <a class="el" href="classNode.html">Node</a> </td></tr>
    <tr><td class="paramname">y</td><td>- the y position of the <a class="el" href="classNode.html">Node</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0757cca6c1f67a44136441ec5f706311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0757cca6c1f67a44136441ec5f706311">&#9670;&nbsp;</a></span>addSubwayEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::addSubwayEdge </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sourceNodeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>destinyNodeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>lineID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an SubwayEdge and adds it to a certain existing <a class="el" href="classNode.html">Node</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceNodeID</td><td>- the ID of the source <a class="el" href="classNode.html">Node</a> of the <a class="el" href="classEdge.html">Edge</a> </td></tr>
    <tr><td class="paramname">destinyNodeID</td><td>- the ID of the destiny <a class="el" href="classNode.html">Node</a> of the <a class="el" href="classEdge.html">Edge</a> </td></tr>
    <tr><td class="paramname">weight</td><td>- the weight of the <a class="el" href="classEdge.html">Edge</a> </td></tr>
    <tr><td class="paramname">lineID</td><td>- the ID of the subway line </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeee0b6743558ef8c3636e720fcf8a72a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee0b6743558ef8c3636e720fcf8a72a">&#9670;&nbsp;</a></span>addWalkEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::addWalkEdge </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sourceNodeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>destinyNodeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>lineID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an WalkEdge and adds it to a certain existing <a class="el" href="classNode.html">Node</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceNodeID</td><td>- the ID of the source <a class="el" href="classNode.html">Node</a> of the <a class="el" href="classEdge.html">Edge</a> </td></tr>
    <tr><td class="paramname">destinyNodeID</td><td>- the ID of the destiny <a class="el" href="classNode.html">Node</a> of the <a class="el" href="classEdge.html">Edge</a> </td></tr>
    <tr><td class="paramname">weight</td><td>- the weight of the <a class="el" href="classEdge.html">Edge</a> </td></tr>
    <tr><td class="paramname">lineID</td><td>- to maintain equality among the other types of edges. In this case, it's always "walk" </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0bbfd0e0f376745c64cc6aef4575868e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bbfd0e0f376745c64cc6aef4575868e">&#9670;&nbsp;</a></span>dijkstra_heap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::dijkstra_heap </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector with the path with the "smallest" distance from the startNode to the endNode, using a heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startNode</td><td>- the beginning <a class="el" href="classNode.html">Node</a> of the path </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0f12b75eac2d9671153262dcc8aeef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0f12b75eac2d9671153262dcc8aeef8">&#9670;&nbsp;</a></span>dijkstra_heap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNode.html">Node</a>&lt; T &gt; * <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::dijkstra_heap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>startNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>endNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector with the path with the "smallest" distance from the startNode to the endNode, implementing Dijkstra, using a heap. </p>
<p>!!! NOT USED !!!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startNode</td><td>- the beginning <a class="el" href="classNode.html">Node</a> of the path </td></tr>
    <tr><td class="paramname">endNode</td><td>- the end <a class="el" href="classNode.html">Node</a> of the path</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classNode.html">Node</a> * - the final <a class="el" href="classNode.html">Node</a> of the path, so we can walk it back to get the best path </dd></dl>

</div>
</div>
<a id="a3472c37dbb3f2a2f71b8d24e8560b454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3472c37dbb3f2a2f71b8d24e8560b454">&#9670;&nbsp;</a></span>dijkstra_queue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNode.html">Node</a>&lt; T &gt; * <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::dijkstra_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>startNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>endNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the path with the "smallest" distance from the startNode to the endNode, implementing Dijkstra, using a mutable priority queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startNode</td><td>- the beginning <a class="el" href="classNode.html">Node</a> of the path </td></tr>
    <tr><td class="paramname">endNode</td><td>- the end <a class="el" href="classNode.html">Node</a> of the path</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classNode.html">Node</a> * - the final <a class="el" href="classNode.html">Node</a> of the path, so we can walk it back to get the best path </dd></dl>

</div>
</div>
<a id="ae3facfe634afadb6f4eb1775b53a02f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3facfe634afadb6f4eb1775b53a02f1">&#9670;&nbsp;</a></span>dijkstra_queue_NO_WALK()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNode.html">Node</a>&lt; T &gt; * <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::dijkstra_queue_NO_WALK </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>startNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>endNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the path with the "smallest" distance from the startNode to the endNode, without walking, implementing Dijkstra, using a mutable priority queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startNode</td><td>- the beginning <a class="el" href="classNode.html">Node</a> of the path </td></tr>
    <tr><td class="paramname">endNode</td><td>- the end <a class="el" href="classNode.html">Node</a> of the path</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classNode.html">Node</a> * - the final <a class="el" href="classNode.html">Node</a> of the path, so we can walk it back to get the best path </dd></dl>

</div>
</div>
<a id="abb6edcfc193c47e8b55bbc537901e4f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6edcfc193c47e8b55bbc537901e4f1">&#9670;&nbsp;</a></span>dijkstra_queue_PRICE()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNode.html">Node</a>&lt; T &gt; * <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::dijkstra_queue_PRICE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>startNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>endNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>walk_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the cheapest path the startNode to the endNode, implementing Dijkstra, using a mutable priority queue. </p>
<p>Since the cheapest path would obviously be always walking, we ask the user the maximum time he wants to spend walking</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startNode</td><td>- the beginning <a class="el" href="classNode.html">Node</a> of the path </td></tr>
    <tr><td class="paramname">endNode</td><td>- the end <a class="el" href="classNode.html">Node</a> of the path </td></tr>
    <tr><td class="paramname">walk_time</td><td>- maximum allowed distance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classNode.html">Node</a> * - the final <a class="el" href="classNode.html">Node</a> of the path, so we can walk it back to get the best path </dd></dl>

</div>
</div>
<a id="a52a9d017001470ed3462888308cd8222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a9d017001470ed3462888308cd8222">&#9670;&nbsp;</a></span>dijkstra_queue_TRANSBORDS()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNode.html">Node</a>&lt; T &gt; * <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::dijkstra_queue_TRANSBORDS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>startNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>endNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the path with the "smallest" distance from the startNode to the endNode, implementing Dijkstra, using a mutable priority queue, and allowing only some exchanges between transports. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startNode</td><td>- the beginning <a class="el" href="classNode.html">Node</a> of the path </td></tr>
    <tr><td class="paramname">endNode</td><td>- the end <a class="el" href="classNode.html">Node</a> of the path </td></tr>
    <tr><td class="paramname">maxNum</td><td>- the maximum allowed number of transports exchanges</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classNode.html">Node</a> * - the final <a class="el" href="classNode.html">Node</a> of the path, so we can walk it back to get the best path </dd></dl>

</div>
</div>
<a id="a100f3444fb02165e585da855d4746c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100f3444fb02165e585da855d4746c63">&#9670;&nbsp;</a></span>findInterfaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::findInterfaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks which nodes of the graph are an interface for the different types of transports. </p>
<p>By interface, we mean a single stop where the user can catch the bus or subway. There will be a certain time of exchanging between them. </p>

</div>
</div>
<a id="acf0ad35640cc7e44ebf1b85c2eb077d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf0ad35640cc7e44ebf1b85c2eb077d8">&#9670;&nbsp;</a></span>getDetailedPath()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classNode.html">Node</a>&lt; T &gt; * &gt; <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::getDetailedPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gives detailed Information about the path to take. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>- the destiny <a class="el" href="classNode.html">Node</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector with the path reversed </dd></dl>

</div>
</div>
<a id="a5655f220455405e30b7fb572f030e3f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5655f220455405e30b7fb572f030e3f6">&#9670;&nbsp;</a></span>getNodeByID()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNode.html">Node</a>&lt; T &gt; * <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::getNodeByID </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a node by its ID. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ID</td><td><a class="el" href="classNode.html">Node</a> ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Node&lt;T&gt;* A pointer to the node </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out_of_range</td><td>If the node doesn't exist </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7901286a40035bfc40410c639238bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7901286a40035bfc40410c639238bc7">&#9670;&nbsp;</a></span>getNodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classNode.html">Node</a>&lt; T &gt; * &gt; <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::getNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all the Nodes in the <a class="el" href="classGraph.html">Graph</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>a vector equal to the Nodes vector in <a class="el" href="classGraph.html">Graph</a> </dd></dl>

</div>
</div>
<a id="a9c2e0a5846210fd7ce91656e1eddc84d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c2e0a5846210fd7ce91656e1eddc84d">&#9670;&nbsp;</a></span>getNumEdges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::getNumEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of Edges in the <a class="el" href="classGraph.html">Graph</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The sum of all the Edges in all the Nodes in the <a class="el" href="classGraph.html">Graph</a> </dd></dl>

</div>
</div>
<a id="aefb367245cc8f3720b02cbd6655f138c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb367245cc8f3720b02cbd6655f138c">&#9670;&nbsp;</a></span>getNumNodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::getNumNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of Nodes in the <a class="el" href="classGraph.html">Graph</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the Nodes vector in the <a class="el" href="classGraph.html">Graph</a> </dd></dl>

</div>
</div>
<a id="a5c543627f13b31885115f25743cc8f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c543627f13b31885115f25743cc8f85">&#9670;&nbsp;</a></span>getPath()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; T &gt; <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::getPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNode.html">Node</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the path to a certain <a class="el" href="classNode.html">Node</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>- the destiny <a class="el" href="classNode.html">Node</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vector with the full path, ordered </dd></dl>

</div>
</div>
<a id="ae1f3e5a786d2f4be17dd94c4626add79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f3e5a786d2f4be17dd94c4626add79">&#9670;&nbsp;</a></span>presentPath()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::presentPath </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classNode.html">Node</a>&lt; T &gt; *&gt;&#160;</td>
          <td class="paramname"><em>invertedPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Presents on the screen the detailed information about the path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">invertedPath</td><td>- a vector with the Nodes of the path, but reversed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Graph_8h_source.html">Graph.h</a></li>
<li>Test.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
